<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Joe Canero</title>
    <description>Joe Canero&#39;s developer site. Check out his blog and his code samples.
</description>
    <link>caneroj1.github.io/</link>
    <atom:link href="caneroj1.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Mon, 17 Aug 2015 20:55:34 -0400</pubDate>
    <lastBuildDate>Mon, 17 Aug 2015 20:55:34 -0400</lastBuildDate>
    <generator>Jekyll v2.5.3</generator>
    
      <item>
        <title>The Meaning of Programs</title>
        <description>&lt;blockquote&gt;
My most recent purchase is the book &lt;a href=&quot;http://computationbook.com&quot;&gt;Understanding Computation&lt;/a&gt; by Tom Stuart, an easy-to-digest text on computer science theory. I first heard about this book on Thoughtbot&#39;s programming podcast, &lt;a href=&quot;https://robots.thoughtbot.com&quot;&gt;Giants Robots Smashing Into Other Giant Robots&lt;/a&gt;, where it was pitched as a theoretical handbook with practical examples all written in Ruby. I&#39;ll be going through the book and blogging about what I learn.
&lt;/blockquote&gt;

&lt;h2 class=&quot;blog-header-2&quot;&gt;What is a program?&lt;/h2&gt;
&lt;h3 class=&quot;blog-header&quot;&gt;A program is...&lt;/h3&gt;
&lt;div class=&quot;blog-container&quot;&gt;
  &lt;div class=&quot;col s12&quot;&gt;
    &lt;p&gt;
      Basically a sequence of instructions given to the computer in order specify how to accomplish a given task. This task can range from something like
      &lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;nb&quot;&gt;puts&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;Hello, World!&amp;quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
    &lt;/p&gt;
    &lt;p&gt;
      to something with millions of lines of code all doing various complicated things. But we shouldn&#39;t write a program with the intention of doing something complicated and hard to understand&amp;mdash;the best programs spring forth from inspiration and are the concretization of ideas.
    &lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;

&lt;h3 class=&quot;blog-header&quot;&gt;Hey, I&#39;ve written a program. Now what?&lt;/h3&gt;
&lt;div class=&quot;blog-container&quot;&gt;
  &lt;div class=&quot;col s12&quot;&gt;
    &lt;p&gt;
      Maybe you just coded your first program, or perhaps it was your thousandth, but it&#39;s still always good to take a step back after you&#39;ve finished the job and look at what you&#39;ve done. Ask yourself: what did I just do (it happens more than you&#39;d think), or does this program actually do what I want it to?
    &lt;/p&gt;
    &lt;p&gt;
      There are a few ways of answering these questions, each with varying complexity, practicality, and expressiveness. But the easiest one, and probably the one you&#39;ve been doing the whole time you were writing the program, is to just read the source code. If your program is small to moderately-sized, doing so allows you to see the structure of your program and how all of the pieces fit together. If your program is larger, maybe run through a few use cases and trace the code by hand. Just by reading the source code, I can usually find more than a few bugs, and sometimes I mark down spots where I know I will have to come back and refactor. But how do you understand programs on a higher level?
    &lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;h2 class=&quot;blog-header-2&quot;&gt;Syntax and Semantics&lt;/h2&gt;
&lt;h3 class=&quot;blog-header&quot;&gt;Let&#39;s Get Theoretical&lt;/h3&gt;
&lt;div class=&quot;blog-container&quot;&gt;
  &lt;div class=&quot;col s12&quot;&gt;
    &lt;p&gt;
      In order to understand programs, we need to understand the languages in which they are written. And to do so, we require an understanding of two things: syntax and semantics.
      The &lt;strong&gt;syntax&lt;/strong&gt; of a language describes its structure and appearance, and the &lt;strong&gt;semantics&lt;/strong&gt; details its meaning, and how its various constructs, such as words and phrases, fit together, and relate to the things they represent.
    &lt;/p&gt;
    &lt;p&gt;
      Once you have the syntax and semantics of a language specified, you can do one of three things. The first thing is what Ruby does: create a reference implementation.
    &lt;/p&gt;
    &lt;p&gt;
      A reference implementation is a programmatic specification of how that language should behave. For example, Ruby has MRI (Matz&#39;s Ruby Interpreter), which is basically the Ruby canon. Reference implementations are useful for describing languages becaue they explicitly show the outputs for given inputs.
    &lt;/p&gt;
    &lt;p&gt;
      The second thing one can do to describe a language is literally write out a formal description of that language. Some of the languages that have formal, written specifications include Java and ECMAScript. These documents are often quite deliberate and technical, and can include things such as formulas for how type inference works, or a description of the language&#39;s keywords.
    &lt;/p&gt;
    &lt;p&gt;
      Or, if one is into this sort of thing, a language can be described mathematically. This is probably the most rigorous and obscure way to describe a language, but it is unambiguous and lends itself to a few different useful things, like automated analysis of the language or even proofs of program correctness.
    &lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;

&lt;h3 class=&quot;blog-header&quot;&gt;Syntax City&lt;/h3&gt;
&lt;div class=&quot;blog-container&quot;&gt;
  &lt;div class=&quot;col s12&quot;&gt;
    &lt;p&gt;
      As I said before, syntax describes the structure and appearance of a language. But more specifically, it describes how to actually &lt;strong&gt;write&lt;/strong&gt; the code for a given language, and specifies what a &quot;correct&quot; program looks like. It says you can&#39;t do something like
      &lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
    &lt;/p&gt;
    &lt;p&gt;
      because there is nothing connecting that 3 to the 7&amp;mdash;it&#39;s not syntactically correct. It also provides rules on how to evaluate ambiguous code and for operator precedence. Like how we have the order of operations in math, Ruby&#39;s syntax dictates that
      &lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
    &lt;/p&gt;
    &lt;p&gt;
      evaluates to 2.
    &lt;/p&gt;
    &lt;p&gt;
      Even though syntax very clearly states what&#39;s right and wrong in any given programming language, we don&#39;t want to do all of that checking by hand. That&#39;s where the &lt;strong&gt;parser&lt;/strong&gt; comes in. It takes as input the source code and turns it into a structured representation of that program, an &lt;strong&gt;abstract syntax tree&lt;/strong&gt;. But there is no one way to understand the meaning behind a program given only the syntax.
    &lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;h3 class=&quot;blog-header&quot;&gt;The Semantics&lt;/h3&gt;
&lt;div class=&quot;blog-container&quot;&gt;
  &lt;div class=&quot;col s12&quot;&gt;
    &lt;p&gt;
       As was mentioned in the beginning of the article, you should be asking yourself: &quot;Does this program do what I want it to do?&quot; Just look at the inputs and see if the outputs are what you expect. But this can be taken to a higher level and provide a framework for analyzing what languages themselves do. That higher level is known as &lt;strong&gt;operational semantics&lt;/strong&gt;.
    &lt;/p&gt;
    &lt;p&gt;
      The operational semantics behind any language is a set of rules that govern how the constructs of that language interact and behave, and most often, these rules are written as if they would be run on an &lt;strong&gt;abstract machine&lt;/strong&gt;. This abstract machine allows us to explicitly capture and explain the behavior of a programming language.
    &lt;/p&gt;
    &lt;p&gt;
      One way of creating an operational semantics is to use what is known as &lt;strong&gt;small-step semantics&lt;/strong&gt;, which is essentially an abstract machine that looks at the syntax of a program, reduces constructs and statements, and produces a final value. For example, a small-step semantics may state that in a series of nested function calls, they be executed in an inner-outer order. The small-step semantics of Ruby, for example, may state that
      &lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;inner&lt;/span&gt;
  &lt;span class=&quot;s2&quot;&gt;&amp;quot;inside&amp;quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;middle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;s2&quot;&gt;&amp;quot;middle &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;outer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;s2&quot;&gt;&amp;quot;outer &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;nb&quot;&gt;puts&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;outer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;middle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;inner&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
    &lt;/p&gt;
    &lt;p&gt;
      evaluates to &quot;outer middle inside&quot; instead of something else, even though all potential versions are syntactically correct.
    &lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;

&lt;div class=&quot;blog-container&quot;&gt;
  &lt;div class=&quot;col s12&quot;&gt;
    &lt;p&gt;
      We can see that there a few different ways of understanding what a program means, from highly rigorous and specific mathematical formulations to programmatic implementations. And to truly understand a programming language, one must know both the syntax and semantics, and how they relate to each other.
    &lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
</description>
        <pubDate>Mon, 17 Aug 2015 00:00:00 -0400</pubDate>
        <link>caneroj1.github.io/ruby/theory/2015/08/17/the-meaning-of-programs.html</link>
        <guid isPermaLink="true">caneroj1.github.io/ruby/theory/2015/08/17/the-meaning-of-programs.html</guid>
        
        
        <category>ruby</category>
        
        <category>theory</category>
        
      </item>
    
      <item>
        <title>Go Scrabble, Part 1</title>
        <description>&lt;blockquote&gt;
  &lt;a href=&quot;https://github.com/caneroj1/scrabble&quot;&gt;caneroj1/scrabble&lt;/a&gt; is my first foray into the Go programming language. It&#39;s a port of my Ruby command-line app for automating keeping score during scrabble. In fact, it&#39;s pretty generic and can probably be used for keeping score in any kind of turn-based game. This post will talk about the Go programming language and what I learned on this project.
&lt;/blockquote&gt;

&lt;h2 class=&quot;blog-header-2&quot;&gt;Prerequisites&lt;/h2&gt;
&lt;h3 class=&quot;blog-header&quot;&gt;Installing Go&lt;/h3&gt;
&lt;div class=&quot;blog-container&quot;&gt;
  &lt;div class=&quot;col s12&quot;&gt;
    &lt;p&gt;
      The Go installation process was pretty painless. I used the Mac OS X Installer available on golang.org&#39;s &lt;a href=&quot;https://golang.org/doc/install&quot;&gt;download page&lt;/a&gt;.
    &lt;/p&gt;
    &lt;p&gt;
      After that&#39;s done, there is some manual setup required. Developing in Go should be done inside a &lt;strong&gt;Go Workspace&lt;/strong&gt;, which is just a fancy name for a specific directory structure, but first we need to take care of some organization.
    &lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;h3 class=&quot;blog-header&quot;&gt;Structuring your Workspace&lt;/h3&gt;
&lt;div class=&quot;blog-container&quot;&gt;
  &lt;div class=&quot;col s12&quot;&gt;
    &lt;p&gt;
      Go&#39;s development toolchain requires things to be structured in a very specific way. So once your install of Go is done, execute this in your terminal
      &lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;n&quot;&gt;mkdir&lt;/span&gt; &lt;span class=&quot;vg&quot;&gt;$HOME&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;go&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
    &lt;/p&gt;
    &lt;p&gt;
      We&#39;re creating our Go workspace inside our $HOME path, which for me is &lt;pre&gt;/Users/jcanero&lt;/pre&gt;
    &lt;/p&gt;
    &lt;p&gt;
      Feel free to set up your workspace anywhere else, but remember to change the following commands appropriately.
    &lt;/p&gt;
    &lt;p&gt;
      Now we need to create the following subdirectories in our workspace.
      &lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;n&quot;&gt;mkdir&lt;/span&gt; &lt;span class=&quot;vg&quot;&gt;$HOME&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bin&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;src&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pkg&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
    &lt;/p&gt;
    &lt;p&gt;
      The &lt;strong&gt;bin&lt;/strong&gt;
      directory is where all of our executable Go programs will be stored. The &lt;strong&gt;pkg&lt;/strong&gt;
      directory is where any libraries or packages built that can be imported are stored. Finally, &lt;strong&gt;src&lt;/strong&gt; is where you will be doing your development.
    &lt;/p&gt;
    &lt;p&gt;
      The &lt;strong&gt;src&lt;/strong&gt; directory should be structured based on the version control system you are using to version your code. For me, I use GitHub, so run the following in terminal
      &lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;n&quot;&gt;mkdir&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;vg&quot;&gt;$HOME&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;go&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;src&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;github&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;com&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;caneroj1&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
    &lt;/p&gt;
    &lt;p&gt;
      but be sure to replace &lt;strong&gt;caneroj1&lt;/strong&gt; with your GitHub account. The last step is to
      &lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;n&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;GOPATH&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;vg&quot;&gt;$HOME&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;go&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
    &lt;/p&gt;
    &lt;p&gt;
      This adds your Go workspace to the GOPATH variable, which the Go toolchain requires to function smoothly. You can also
      &lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;n&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;PATH&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;vg&quot;&gt;$PATH&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;vg&quot;&gt;$GOPATH&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bin&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
    &lt;/p&gt;
    &lt;p&gt;
      which adds the &lt;strong&gt;bin&lt;/strong&gt; directory of your workspace to your $PATH so you can execute built binaries anywhere. Now that is all taken care of...
    &lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;h2 class=&quot;blog-header-2&quot;&gt;Go Code&lt;/h2&gt;
&lt;h3 class=&quot;blog-header&quot;&gt;Understanding Imports&lt;/h3&gt;
&lt;div class=&quot;blog-container&quot;&gt;
  &lt;div class=&quot;col sm-12&quot;&gt;
    &lt;p&gt;
      You can easily get the code by executing
      &lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;n&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;github&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;com&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;caneroj1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;scrabble&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
    &lt;/p&gt;
    &lt;p&gt;
      The Go tool will fetch the code from my repo and add it to your workspace.
    &lt;/p&gt;
    &lt;p&gt;
      The main code is in the &lt;strong&gt;scrabble.go&lt;/strong&gt; file, as denoted by the
      &lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span class=&quot;kn&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;main&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
    &lt;/p&gt;
    &lt;p&gt;
      at the top. You can see there are quite a few import statements, too.
      &lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;&amp;quot;fmt&amp;quot;&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;&amp;quot;os&amp;quot;&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;&amp;quot;strconv&amp;quot;&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;&amp;quot;github.com/caneroj1/scrabble/go/player&amp;quot;&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;&amp;quot;github.com/caneroj1/scrabble/go/reader&amp;quot;&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;&amp;quot;github.com/caneroj1/scrabble/go/game&amp;quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

    &lt;/p&gt;
    &lt;p&gt;
      Importing &lt;strong&gt;fmt&lt;/strong&gt; allows us to do things like print to the screen or print interpolated strings, like with
      &lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span class=&quot;nx&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Hello World&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
    &lt;/p&gt;
    &lt;p&gt;
      Or
      &lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span class=&quot;nx&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;%d bottles of beer on the wall&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;99&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
    &lt;/p&gt;
    &lt;p&gt;
      Import &lt;strong&gt;os&lt;/strong&gt; provides access to functions like &lt;strong&gt;Exit()&lt;/strong&gt;, which I use to exit the program when I encounter an error, or variables like &lt;strong&gt;os.Stdin&lt;/strong&gt;, which points to the standard input.
    &lt;/p&gt;
    &lt;p&gt;
      Importing &lt;strong&gt;strconv&lt;/strong&gt; gives us useful functions like &lt;strong&gt;strconv.ParseInt()&lt;/strong&gt;. The next three lines are importing code specific to the &lt;strong&gt;github.com/caneroj1/scrabble&lt;/strong&gt; repository. If you look inside that directory, you can see there is a &lt;strong&gt;go&lt;/strong&gt; directory, containing the &lt;strong&gt;player&lt;/strong&gt;, &lt;strong&gt;reader&lt;/strong&gt;, and &lt;strong&gt;game&lt;/strong&gt; directories. The import statements give us access to exported identifiers in those directories.
    &lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;


&lt;h3 class=&quot;blog-header&quot;&gt;The Business of Exports&lt;/h3&gt;
&lt;div class=&quot;blog-container&quot;&gt;
  &lt;div class=&quot;col sm-12&quot;&gt;
    &lt;p&gt;
      What does it mean for an identifier to exported?
    &lt;/p&gt;
    &lt;p&gt;
      Before we can answer that question, we need to first understand what identifiers are.
    &lt;/p&gt;
    &lt;p&gt;
      An identifier is usually a keyword, and can be something like a variable name, or a function, or constant declaration.
      &lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
    &lt;/p&gt;
    &lt;p&gt;
      In the above code, &lt;strong&gt;add&lt;/strong&gt; is an identifier representing that function, and &lt;strong&gt;name&lt;/strong&gt; is an identifier representing a string.
    &lt;/p&gt;
    &lt;p&gt;
      There are also a few special types of identifiers in Go. Variable &lt;em&gt;types&lt;/em&gt; in Go, such as int, int8, string, uint, and bool are called &lt;strong&gt;predeclared identifiers&lt;/strong&gt;, and they are available at what is called the &lt;strong&gt;universe block&lt;/strong&gt;, which is, literally, anywhere.
    &lt;/p&gt;
    &lt;p&gt;
      Another type of identifier is called the &lt;strong&gt;blank identifier&lt;/strong&gt; and that is represented by a single &lt;strong&gt;_&lt;/strong&gt;. It is a placeholder for a variable. It can be used in situations like
      &lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span class=&quot;nx&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;make&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;range&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
    &lt;/p&gt;
    &lt;p&gt;
      to get only a named reference to each value in &lt;strong&gt;n&lt;/strong&gt; through &lt;strong&gt;v&lt;/strong&gt; and ignore the first return value of &lt;strong&gt;range&lt;/strong&gt;.
    &lt;/p&gt;
    &lt;p&gt;
      Now, an exported identifier is an identifier that is accessible across packages. Any identifier is exported if it begins with a capitalized Unicode letter and it is declared at the &lt;strong&gt;package level&lt;/strong&gt;.
      Let&#39;s export the code from above.
      &lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span class=&quot;kn&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;test&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Name&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
    &lt;/p&gt;
    &lt;p&gt;
      As simply as that, we can access the variable &lt;strong&gt;Name&lt;/strong&gt; or call the function &lt;strong&gt;Add&lt;/strong&gt; from any other package that imports &lt;strong&gt;test&lt;/strong&gt;.
    &lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;h3 class=&quot;blog-header&quot;&gt;Part 2 is coming soon!&lt;/h3&gt;
</description>
        <pubDate>Sat, 15 Aug 2015 00:00:00 -0400</pubDate>
        <link>caneroj1.github.io/go/scrabble/2015/08/15/go-scrabble_part_1.html</link>
        <guid isPermaLink="true">caneroj1.github.io/go/scrabble/2015/08/15/go-scrabble_part_1.html</guid>
        
        
        <category>go</category>
        
        <category>scrabble</category>
        
      </item>
    
      <item>
        <title>Awesome Beer Fridge</title>
        <description>&lt;blockquote&gt;
  The &quot;Beer Fridge of Awesomeness&quot; is a cool project I found on &lt;a href=&quot;https://github.com/InitialState/beerfridge&quot;&gt;Github&lt;/a&gt;
  that walks you through using a Raspberry Pi to build your very own smart beer fridge!
  The Beer Fridge can detect when it&#39;s open, measure its temperature and count the number of bottles inside.
&lt;/blockquote&gt;

&lt;h3 class=&quot;blog-header&quot;&gt;First Things First&lt;/h3&gt;
&lt;div class=&quot;blog-container&quot;&gt;
  &lt;div class=&quot;col s12 m6&quot;&gt;
    &lt;p&gt;
      I&#39;ve never used a Raspberry Pi before, so first I had to get my Ultimate Starter Kit. The project has a pretty long list of required parts, so I had to order those as well.
    &lt;/p&gt;
    &lt;p&gt;
      Amongst other things, I ordered a digital thermometer and some door sensors, and the total cost for everything was around $120.
    &lt;/p&gt;
  &lt;/div&gt;
  &lt;div class=&quot;col s12 m6&quot;&gt;
    &lt;img class=&#39;blog-post-pic&#39; src=&#39;/images/6272015setup.jpg&#39;&gt;
  &lt;/div&gt;
&lt;/div&gt;

&lt;h3 class=&quot;blog-header&quot;&gt;The Pi is Almost Done&lt;/h3&gt;
&lt;div class=&quot;blog-container&quot;&gt;
  &lt;div class=&quot;col s12 m6&quot;&gt;
    &lt;p&gt;
      Installing Raspbian, the default Raspberry Pi OS was pretty simple. There&#39;s a tool called
      NOOBS, that pretty much does it for you.
    &lt;/p&gt;
    &lt;p&gt;
      I was pretty much playing the waiting game at this point.
    &lt;/p&gt;
  &lt;/div&gt;
  &lt;div class=&quot;col s12 m6&quot;&gt;
    &lt;img class=&#39;blog-post-pic&#39; src=&#39;/images/6272015rbpi.jpg&#39;&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;h3 class=&quot;blog-header&quot;&gt;Next Steps&lt;/h3&gt;
&lt;div class=&quot;blog-container&quot;&gt;
  &lt;p&gt;
      The Raspberry Pi needed some way to count the number of bottles in the fridge, so I had to
      connect the Raspberry Pi, via bluetooth, to a Wii Fit Balance Board and place the fridge on top.
      Then I was able to measure the weight of the       fridge.
  &lt;/p&gt;
  &lt;div class=&quot;center-align&quot;&gt;
    &lt;img class=&#39;blog-post-pic&#39; src=&#39;/images/6272015wii.jpg&#39; style=&#39;width: 60%;&#39;&gt;
  &lt;/div&gt;
  &lt;p&gt;
      The next step was to start wiring everything up.
      Some of the parts necessary for the beer fridge to be totally awesome include a temperature sensor
      and a door sensor. Getting these working with the Raspberry Pi was the most difficult part of the project,
      and required a steady hand. Below is the fully wired Pi.
  &lt;/p&gt;
  &lt;div class=&quot;center-align&quot;&gt;
    &lt;img class=&#39;blog-post-pic&#39; src=&#39;/images/6272015fridge.jpg&#39; style=&#39;width: 60%;&#39;&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;h3 class=&quot;blog-header&quot;&gt;Finishing Up&lt;/h3&gt;
&lt;div class=&quot;blog-container&quot;&gt;
  &lt;div class=&#39;col m6 s12&#39;&gt;
    &lt;p&gt;
      All the sensors were working at this point, so it was time to fill the fridge! As I mentioned before, you should fill
      the fridge with beverages that all weigh pretty much the same. After loading up on Summer Shandy, I weighed the fridge with
      the bottles inside in order to determine each bottle&#39;s weight.
    &lt;/p&gt;
  &lt;/div&gt;
  &lt;div class=&#39;col m6 s12&#39;&gt;
    &lt;img class=&#39;blog-post-pic&#39; src=&#39;/images/6272015beer.jpg&#39; style=&#39;width: 80%;&#39;&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;h3 class=&quot;blog-header&quot;&gt;Project Complete!&lt;/h3&gt;
&lt;div class=&quot;blog-container&quot;&gt;
  &lt;p&gt;
      Finally, the tutorial sets you up on a neat visualization dashboard where you can see the status of your beer fridge and monitor
      things like temperature and the number of bottles inside.
  &lt;/p&gt;
  &lt;div class=&quot;center-align&quot;&gt;
    &lt;img class=&#39;blog-post-pic&#39; src=&#39;/images/6272015final.png&#39; style=&#39;width:80%;&#39;&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;h3 class=&quot;blog-header&quot;&gt;Closing Remarks&lt;/h3&gt;
&lt;div class=&quot;blog-container&quot;&gt;
  &lt;p&gt;
      In the end, I thought the Beer Fridge of Awesomeness was a nice project to help me kill some time. It was my first exposure
      to working with a Raspberry Pi, and I learned a fair amount about setting up circuits and other hardware. I&#39;m on the lookout for my next
      project!
  &lt;/p&gt;
&lt;/div&gt;
</description>
        <pubDate>Sat, 27 Jun 2015 00:00:00 -0400</pubDate>
        <link>caneroj1.github.io/raspberrypi/node/js/2015/06/27/awesome-beer-fridge.html</link>
        <guid isPermaLink="true">caneroj1.github.io/raspberrypi/node/js/2015/06/27/awesome-beer-fridge.html</guid>
        
        
        <category>raspberrypi</category>
        
        <category>node</category>
        
        <category>js</category>
        
      </item>
    
  </channel>
</rss>
